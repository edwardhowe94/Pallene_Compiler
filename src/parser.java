
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

import java_cup.runtime.*;
import syntaxTree.*;
import syntaxTree.expr.constant.*;
import syntaxTree.expr.binaryexpr.arithop.*;
import syntaxTree.statement.ASSIGNMENT.*;
import syntaxTree.expr.unaryexpr.*;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import javax.xml.parsers.DocumentBuilder;
import org.w3c.dom.Attr;
import javax.xml.parsers.DocumentBuilderFactory;
import syntaxTree.statement.Conditional.IF_THEN;
import syntaxTree.statement.Conditional.IF_THEN_ELSE;
import syntaxTree.expr.binaryexpr.relop.*;
import syntaxTree.statement.Others.NOP;
import syntaxTree.statement.Others.WHILE_DO;
import syntaxTree.statement.Others.ID_STATEMENT;
import syntaxTree.statement.Others.LOCAL;
import syntaxTree.statement.Others.FOR;
import syntaxTree.statement.Others.RETURN;
import syntaxTree.statement.Others.ARRAY_STAT;
import syntaxTree.statement.IO.READ;
import syntaxTree.statement.IO.WRITE;
import java.util.*;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  @Deprecated
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\105\000\002\002\004\000\002\002\004\000\002\003" +
    "\005\000\002\003\002\000\002\004\004\000\002\004\003" +
    "\000\002\007\003\000\002\007\003\000\002\006\013\000" +
    "\002\006\012\000\002\010\007\000\002\010\005\000\002" +
    "\005\010\000\002\005\006\000\002\020\004\000\002\020" +
    "\002\000\002\011\003\000\002\011\003\000\002\011\003" +
    "\000\002\011\003\000\002\011\003\000\002\011\005\000" +
    "\002\011\007\000\002\011\006\000\002\012\005\000\002" +
    "\012\003\000\002\013\005\000\002\013\003\000\002\014" +
    "\003\000\002\014\007\000\002\014\011\000\002\014\007" +
    "\000\002\014\013\000\002\014\007\000\002\014\005\000" +
    "\002\014\010\000\002\014\006\000\002\014\004\000\002" +
    "\014\004\000\002\014\004\000\002\016\005\000\002\016" +
    "\003\000\002\015\003\000\002\015\003\000\002\015\003" +
    "\000\002\015\003\000\002\015\003\000\002\015\003\000" +
    "\002\015\003\000\002\015\006\000\002\015\003\000\002" +
    "\015\006\000\002\015\005\000\002\015\006\000\002\015" +
    "\005\000\002\015\005\000\002\015\005\000\002\015\005" +
    "\000\002\015\005\000\002\015\005\000\002\015\005\000" +
    "\002\015\005\000\002\015\005\000\002\015\005\000\002" +
    "\015\005\000\002\015\005\000\002\015\004\000\002\015" +
    "\004\000\002\015\004" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\242\000\006\011\ufffe\063\005\001\002\000\004\011" +
    "\136\001\002\000\004\056\010\001\002\000\004\002\007" +
    "\001\002\000\004\002\001\001\002\000\004\041\131\001" +
    "\002\000\006\014\013\042\012\001\002\000\004\056\014" +
    "\001\002\000\004\011\uffff\001\002\000\004\041\015\001" +
    "\002\000\020\013\024\015\023\016\025\017\022\020\017" +
    "\025\021\031\020\001\002\000\010\014\ufff2\042\ufff2\055" +
    "\043\001\002\000\126\004\uffed\005\uffed\006\uffed\007\uffed" +
    "\010\uffed\013\uffed\014\uffed\022\uffed\023\uffed\024\uffed\026" +
    "\uffed\027\uffed\030\uffed\031\uffed\032\uffed\033\uffed\034\uffed" +
    "\035\uffed\036\uffed\040\uffed\042\uffed\043\uffed\044\uffed\045" +
    "\uffed\046\uffed\047\uffed\050\uffed\051\uffed\052\uffed\053\uffed" +
    "\054\uffed\055\uffed\056\uffed\057\uffed\060\uffed\061\uffed\062" +
    "\uffed\064\uffed\065\uffed\067\uffed\070\uffed\072\uffed\001\002" +
    "\000\020\013\024\015\023\016\025\017\022\020\017\025" +
    "\021\031\020\001\002\000\022\013\024\015\023\016\025" +
    "\017\022\020\017\025\021\026\030\031\020\001\002\000" +
    "\126\004\uffef\005\uffef\006\uffef\007\uffef\010\uffef\013\uffef" +
    "\014\uffef\022\uffef\023\uffef\024\uffef\026\uffef\027\uffef\030" +
    "\uffef\031\uffef\032\uffef\033\uffef\034\uffef\035\uffef\036\uffef" +
    "\040\uffef\042\uffef\043\uffef\044\uffef\045\uffef\046\uffef\047" +
    "\uffef\050\uffef\051\uffef\052\uffef\053\uffef\054\uffef\055\uffef" +
    "\056\uffef\057\uffef\060\uffef\061\uffef\062\uffef\064\uffef\065" +
    "\uffef\067\uffef\070\uffef\072\uffef\001\002\000\126\004\uffee" +
    "\005\uffee\006\uffee\007\uffee\010\uffee\013\uffee\014\uffee\022" +
    "\uffee\023\uffee\024\uffee\026\uffee\027\uffee\030\uffee\031\uffee" +
    "\032\uffee\033\uffee\034\uffee\035\uffee\036\uffee\040\uffee\042" +
    "\uffee\043\uffee\044\uffee\045\uffee\046\uffee\047\uffee\050\uffee" +
    "\051\uffee\052\uffee\053\uffee\054\uffee\055\uffee\056\uffee\057" +
    "\uffee\060\uffee\061\uffee\062\uffee\064\uffee\065\uffee\067\uffee" +
    "\070\uffee\072\uffee\001\002\000\126\004\ufff1\005\ufff1\006" +
    "\ufff1\007\ufff1\010\ufff1\013\ufff1\014\ufff1\022\ufff1\023\ufff1" +
    "\024\ufff1\026\ufff1\027\ufff1\030\ufff1\031\ufff1\032\ufff1\033" +
    "\ufff1\034\ufff1\035\ufff1\036\ufff1\040\ufff1\042\ufff1\043\ufff1" +
    "\044\ufff1\045\ufff1\046\ufff1\047\ufff1\050\ufff1\051\ufff1\052" +
    "\ufff1\053\ufff1\054\ufff1\055\ufff1\056\ufff1\057\ufff1\060\ufff1" +
    "\061\ufff1\062\ufff1\064\ufff1\065\ufff1\067\ufff1\070\ufff1\072" +
    "\ufff1\001\002\000\126\004\ufff0\005\ufff0\006\ufff0\007\ufff0" +
    "\010\ufff0\013\ufff0\014\ufff0\022\ufff0\023\ufff0\024\ufff0\026" +
    "\ufff0\027\ufff0\030\ufff0\031\ufff0\032\ufff0\033\ufff0\034\ufff0" +
    "\035\ufff0\036\ufff0\040\ufff0\042\ufff0\043\ufff0\044\ufff0\045" +
    "\ufff0\046\ufff0\047\ufff0\050\ufff0\051\ufff0\052\ufff0\053\ufff0" +
    "\054\ufff0\055\ufff0\056\ufff0\057\ufff0\060\ufff0\061\ufff0\062" +
    "\ufff0\064\ufff0\065\ufff0\067\ufff0\070\ufff0\072\ufff0\001\002" +
    "\000\006\026\uffe8\040\036\001\002\000\004\026\033\001" +
    "\002\000\004\021\031\001\002\000\020\013\024\015\023" +
    "\016\025\017\022\020\017\025\021\031\020\001\002\000" +
    "\126\004\uffea\005\uffea\006\uffea\007\uffea\010\uffea\013\uffea" +
    "\014\uffea\022\uffea\023\uffea\024\uffea\026\uffea\027\uffea\030" +
    "\uffea\031\uffea\032\uffea\033\uffea\034\uffea\035\uffea\036\uffea" +
    "\040\uffea\042\uffea\043\uffea\044\uffea\045\uffea\046\uffea\047" +
    "\uffea\050\uffea\051\uffea\052\uffea\053\uffea\054\uffea\055\uffea" +
    "\056\uffea\057\uffea\060\uffea\061\uffea\062\uffea\064\uffea\065" +
    "\uffea\067\uffea\070\uffea\072\uffea\001\002\000\004\021\034" +
    "\001\002\000\020\013\024\015\023\016\025\017\022\020" +
    "\017\025\021\031\020\001\002\000\126\004\uffeb\005\uffeb" +
    "\006\uffeb\007\uffeb\010\uffeb\013\uffeb\014\uffeb\022\uffeb\023" +
    "\uffeb\024\uffeb\026\uffeb\027\uffeb\030\uffeb\031\uffeb\032\uffeb" +
    "\033\uffeb\034\uffeb\035\uffeb\036\uffeb\040\uffeb\042\uffeb\043" +
    "\uffeb\044\uffeb\045\uffeb\046\uffeb\047\uffeb\050\uffeb\051\uffeb" +
    "\052\uffeb\053\uffeb\054\uffeb\055\uffeb\056\uffeb\057\uffeb\060" +
    "\uffeb\061\uffeb\062\uffeb\064\uffeb\065\uffeb\067\uffeb\070\uffeb" +
    "\072\uffeb\001\002\000\020\013\024\015\023\016\025\017" +
    "\022\020\017\025\021\031\020\001\002\000\004\026\uffe9" +
    "\001\002\000\004\032\041\001\002\000\126\004\uffec\005" +
    "\uffec\006\uffec\007\uffec\010\uffec\013\uffec\014\uffec\022\uffec" +
    "\023\uffec\024\uffec\026\uffec\027\uffec\030\uffec\031\uffec\032" +
    "\uffec\033\uffec\034\uffec\035\uffec\036\uffec\040\uffec\042\uffec" +
    "\043\uffec\044\uffec\045\uffec\046\uffec\047\uffec\050\uffec\051" +
    "\uffec\052\uffec\053\uffec\054\uffec\055\uffec\056\uffec\057\uffec" +
    "\060\uffec\061\uffec\062\uffec\064\uffec\065\uffec\067\uffec\070" +
    "\uffec\072\uffec\001\002\000\006\014\ufff5\042\ufff5\001\002" +
    "\000\032\013\051\031\055\034\044\051\057\054\046\056" +
    "\056\057\052\060\054\065\047\067\045\070\060\072\053" +
    "\001\002\000\032\013\051\031\055\034\044\051\057\054" +
    "\046\056\056\057\052\060\054\065\047\067\045\070\060" +
    "\072\053\001\002\000\060\005\uffd4\006\uffd4\010\uffd4\014" +
    "\uffd4\026\uffd4\027\uffd4\030\uffd4\033\uffd4\034\uffd4\035\uffd4" +
    "\036\uffd4\040\uffd4\042\uffd4\043\uffd4\044\uffd4\045\uffd4\046" +
    "\uffd4\047\uffd4\050\uffd4\052\uffd4\053\uffd4\061\uffd4\062\uffd4" +
    "\001\002\000\032\013\051\031\055\034\044\051\057\054" +
    "\046\056\056\057\052\060\054\065\047\067\045\070\060" +
    "\072\053\001\002\000\060\005\uffd2\006\uffd2\010\uffd2\014" +
    "\uffd2\026\uffd2\027\uffd2\030\uffd2\033\uffd2\034\uffd2\035\uffd2" +
    "\036\uffd2\040\uffd2\042\uffd2\043\uffd2\044\uffd2\045\uffd2\046" +
    "\uffd2\047\uffd2\050\uffd2\052\uffd2\053\uffd2\061\uffd2\062\uffd2" +
    "\001\002\000\040\014\ufff3\027\064\033\067\034\062\035" +
    "\073\036\071\042\ufff3\043\072\044\065\045\075\046\070" +
    "\047\066\050\074\052\063\053\076\001\002\000\060\005" +
    "\uffd7\006\uffd7\010\uffd7\014\uffd7\026\uffd7\027\uffd7\030\uffd7" +
    "\033\uffd7\034\uffd7\035\uffd7\036\uffd7\040\uffd7\042\uffd7\043" +
    "\uffd7\044\uffd7\045\uffd7\046\uffd7\047\uffd7\050\uffd7\052\uffd7" +
    "\053\uffd7\061\uffd7\062\uffd7\001\002\000\060\005\uffd6\006" +
    "\uffd6\010\uffd6\014\uffd6\026\uffd6\027\uffd6\030\uffd6\033\uffd6" +
    "\034\uffd6\035\uffd6\036\uffd6\040\uffd6\042\uffd6\043\uffd6\044" +
    "\uffd6\045\uffd6\046\uffd6\047\uffd6\050\uffd6\052\uffd6\053\uffd6" +
    "\061\uffd6\062\uffd6\001\002\000\060\005\uffd1\006\uffd1\010" +
    "\uffd1\014\uffd1\026\uffd1\027\uffd1\030\uffd1\033\uffd1\034\uffd1" +
    "\035\uffd1\036\uffd1\040\uffd1\042\uffd1\043\uffd1\044\uffd1\045" +
    "\uffd1\046\uffd1\047\uffd1\050\uffd1\052\uffd1\053\uffd1\061\uffd1" +
    "\062\uffd1\001\002\000\060\005\uffd5\006\uffd5\010\uffd5\014" +
    "\uffd5\026\uffd5\027\uffd5\030\uffd5\033\uffd5\034\uffd5\035\uffd5" +
    "\036\uffd5\040\uffd5\042\uffd5\043\uffd5\044\uffd5\045\uffd5\046" +
    "\uffd5\047\uffd5\050\uffd5\052\uffd5\053\uffd5\061\uffd5\062\uffd5" +
    "\001\002\000\004\032\124\001\002\000\062\005\uffcf\006" +
    "\uffcf\010\uffcf\014\uffcf\025\115\026\uffcf\027\uffcf\030\uffcf" +
    "\033\uffcf\034\uffcf\035\uffcf\036\uffcf\040\uffcf\042\uffcf\043" +
    "\uffcf\044\uffcf\045\uffcf\046\uffcf\047\uffcf\050\uffcf\052\uffcf" +
    "\053\uffcf\061\uffcf\062\uffcf\001\002\000\032\013\051\031" +
    "\055\034\044\051\057\054\046\056\056\057\052\060\054" +
    "\065\047\067\045\070\060\072\053\001\002\000\060\005" +
    "\uffd3\006\uffd3\010\uffd3\014\uffd3\026\uffd3\027\uffd3\030\uffd3" +
    "\033\uffd3\034\uffd3\035\uffd3\036\uffd3\040\uffd3\042\uffd3\043" +
    "\uffd3\044\uffd3\045\uffd3\046\uffd3\047\uffd3\050\uffd3\052\uffd3" +
    "\053\uffd3\061\uffd3\062\uffd3\001\002\000\060\005\uffbe\006" +
    "\uffbe\010\uffbe\014\uffbe\026\uffbe\027\064\030\uffbe\033\067" +
    "\034\062\035\073\036\071\040\uffbe\042\uffbe\043\uffbe\044" +
    "\uffbe\045\uffbe\046\uffbe\047\uffbe\050\uffbe\052\uffbe\053\uffbe" +
    "\061\uffbe\062\uffbe\001\002\000\032\013\051\031\055\034" +
    "\044\051\057\054\046\056\056\057\052\060\054\065\047" +
    "\067\045\070\060\072\053\001\002\000\032\013\051\031" +
    "\055\034\044\051\057\054\046\056\056\057\052\060\054" +
    "\065\047\067\045\070\060\072\053\001\002\000\032\013" +
    "\051\031\055\034\044\051\057\054\046\056\056\057\052" +
    "\060\054\065\047\067\045\070\060\072\053\001\002\000" +
    "\032\013\051\031\055\034\044\051\057\054\046\056\056" +
    "\057\052\060\054\065\047\067\045\070\060\072\053\001" +
    "\002\000\032\013\051\031\055\034\044\051\057\054\046" +
    "\056\056\057\052\060\054\065\047\067\045\070\060\072" +
    "\053\001\002\000\032\013\051\031\055\034\044\051\057" +
    "\054\046\056\056\057\052\060\054\065\047\067\045\070" +
    "\060\072\053\001\002\000\032\013\051\031\055\034\044" +
    "\051\057\054\046\056\056\057\052\060\054\065\047\067" +
    "\045\070\060\072\053\001\002\000\032\013\051\031\055" +
    "\034\044\051\057\054\046\056\056\057\052\060\054\065" +
    "\047\067\045\070\060\072\053\001\002\000\032\013\051" +
    "\031\055\034\044\051\057\054\046\056\056\057\052\060" +
    "\054\065\047\067\045\070\060\072\053\001\002\000\032" +
    "\013\051\031\055\034\044\051\057\054\046\056\056\057" +
    "\052\060\054\065\047\067\045\070\060\072\053\001\002" +
    "\000\032\013\051\031\055\034\044\051\057\054\046\056" +
    "\056\057\052\060\054\065\047\067\045\070\060\072\053" +
    "\001\002\000\032\013\051\031\055\034\044\051\057\054" +
    "\046\056\056\057\052\060\054\065\047\067\045\070\060" +
    "\072\053\001\002\000\032\013\051\031\055\034\044\051" +
    "\057\054\046\056\056\057\052\060\054\065\047\067\045" +
    "\070\060\072\053\001\002\000\060\005\uffc6\006\uffc6\010" +
    "\uffc6\014\uffc6\026\uffc6\027\064\030\uffc6\033\067\034\062" +
    "\035\073\036\071\040\uffc6\042\uffc6\043\072\044\065\045" +
    "\075\046\070\047\066\050\074\052\uffc6\053\uffc6\061\uffc6" +
    "\062\uffc6\001\002\000\060\005\uffc3\006\uffc3\010\uffc3\014" +
    "\uffc3\026\uffc3\027\064\030\uffc3\033\067\034\062\035\073" +
    "\036\071\040\uffc3\042\uffc3\043\uffc3\044\uffc3\045\uffc3\046" +
    "\uffc3\047\uffc3\050\uffc3\052\uffc3\053\uffc3\061\uffc3\062\uffc3" +
    "\001\002\000\060\005\uffc0\006\uffc0\010\uffc0\014\uffc0\026" +
    "\uffc0\027\064\030\uffc0\033\067\034\062\035\073\036\071" +
    "\040\uffc0\042\uffc0\043\uffc0\044\uffc0\045\uffc0\046\uffc0\047" +
    "\uffc0\050\uffc0\052\uffc0\053\uffc0\061\uffc0\062\uffc0\001\002" +
    "\000\060\005\uffc9\006\uffc9\010\uffc9\014\uffc9\026\uffc9\027" +
    "\064\030\uffc9\033\uffc9\034\uffc9\035\uffc9\036\uffc9\040\uffc9" +
    "\042\uffc9\043\uffc9\044\uffc9\045\uffc9\046\uffc9\047\uffc9\050" +
    "\uffc9\052\uffc9\053\uffc9\061\uffc9\062\uffc9\001\002\000\060" +
    "\005\uffc5\006\uffc5\010\uffc5\014\uffc5\026\uffc5\027\064\030" +
    "\uffc5\033\067\034\062\035\073\036\071\040\uffc5\042\uffc5" +
    "\043\uffc5\044\uffc5\045\uffc5\046\uffc5\047\uffc5\050\uffc5\052" +
    "\uffc5\053\uffc5\061\uffc5\062\uffc5\001\002\000\060\005\uffc8" +
    "\006\uffc8\010\uffc8\014\uffc8\026\uffc8\027\064\030\uffc8\033" +
    "\uffc8\034\uffc8\035\uffc8\036\uffc8\040\uffc8\042\uffc8\043\uffc8" +
    "\044\uffc8\045\uffc8\046\uffc8\047\uffc8\050\uffc8\052\uffc8\053" +
    "\uffc8\061\uffc8\062\uffc8\001\002\000\060\005\uffc2\006\uffc2" +
    "\010\uffc2\014\uffc2\026\uffc2\027\064\030\uffc2\033\067\034" +
    "\062\035\073\036\071\040\uffc2\042\uffc2\043\uffc2\044\uffc2" +
    "\045\uffc2\046\uffc2\047\uffc2\050\uffc2\052\uffc2\053\uffc2\061" +
    "\uffc2\062\uffc2\001\002\000\060\005\uffcb\006\uffcb\010\uffcb" +
    "\014\uffcb\026\uffcb\027\064\030\uffcb\033\uffcb\034\uffcb\035" +
    "\073\036\071\040\uffcb\042\uffcb\043\uffcb\044\uffcb\045\uffcb" +
    "\046\uffcb\047\uffcb\050\uffcb\052\uffcb\053\uffcb\061\uffcb\062" +
    "\uffcb\001\002\000\060\005\uffc1\006\uffc1\010\uffc1\014\uffc1" +
    "\026\uffc1\027\064\030\uffc1\033\067\034\062\035\073\036" +
    "\071\040\uffc1\042\uffc1\043\uffc1\044\uffc1\045\uffc1\046\uffc1" +
    "\047\uffc1\050\uffc1\052\uffc1\053\uffc1\061\uffc1\062\uffc1\001" +
    "\002\000\060\005\uffc4\006\uffc4\010\uffc4\014\uffc4\026\uffc4" +
    "\027\064\030\uffc4\033\067\034\062\035\073\036\071\040" +
    "\uffc4\042\uffc4\043\uffc4\044\uffc4\045\uffc4\046\uffc4\047\uffc4" +
    "\050\uffc4\052\uffc4\053\uffc4\061\uffc4\062\uffc4\001\002\000" +
    "\036\027\064\030\112\033\067\034\062\035\073\036\071" +
    "\043\072\044\065\045\075\046\070\047\066\050\074\052" +
    "\063\053\076\001\002\000\060\005\uffce\006\uffce\010\uffce" +
    "\014\uffce\026\uffce\027\uffce\030\uffce\033\uffce\034\uffce\035" +
    "\uffce\036\uffce\040\uffce\042\uffce\043\uffce\044\uffce\045\uffce" +
    "\046\uffce\047\uffce\050\uffce\052\uffce\053\uffce\061\uffce\062" +
    "\uffce\001\002\000\060\005\uffc7\006\uffc7\010\uffc7\014\uffc7" +
    "\026\uffc7\027\064\030\uffc7\033\067\034\062\035\073\036" +
    "\071\040\uffc7\042\uffc7\043\072\044\065\045\075\046\070" +
    "\047\066\050\074\052\uffc7\053\uffc7\061\uffc7\062\uffc7\001" +
    "\002\000\060\005\uffca\006\uffca\010\uffca\014\uffca\026\uffca" +
    "\027\064\030\uffca\033\uffca\034\uffca\035\073\036\071\040" +
    "\uffca\042\uffca\043\uffca\044\uffca\045\uffca\046\uffca\047\uffca" +
    "\050\uffca\052\uffca\053\uffca\061\uffca\062\uffca\001\002\000" +
    "\034\013\051\026\120\031\055\034\044\051\057\054\046" +
    "\056\056\057\052\060\054\065\047\067\045\070\060\072" +
    "\053\001\002\000\044\026\uffd8\027\064\033\067\034\062" +
    "\035\073\036\071\040\122\043\072\044\065\045\075\046" +
    "\070\047\066\050\074\052\063\053\076\061\uffd8\062\uffd8" +
    "\001\002\000\004\026\121\001\002\000\060\005\uffcd\006" +
    "\uffcd\010\uffcd\014\uffcd\026\uffcd\027\uffcd\030\uffcd\033\uffcd" +
    "\034\uffcd\035\uffcd\036\uffcd\040\uffcd\042\uffcd\043\uffcd\044" +
    "\uffcd\045\uffcd\046\uffcd\047\uffcd\050\uffcd\052\uffcd\053\uffcd" +
    "\061\uffcd\062\uffcd\001\002\000\060\005\uffcc\006\uffcc\010" +
    "\uffcc\014\uffcc\026\uffcc\027\uffcc\030\uffcc\033\uffcc\034\uffcc" +
    "\035\uffcc\036\uffcc\040\uffcc\042\uffcc\043\uffcc\044\uffcc\045" +
    "\uffcc\046\uffcc\047\uffcc\050\uffcc\052\uffcc\053\uffcc\061\uffcc" +
    "\062\uffcc\001\002\000\032\013\051\031\055\034\044\051" +
    "\057\054\046\056\056\057\052\060\054\065\047\067\045" +
    "\070\060\072\053\001\002\000\010\026\uffd9\061\uffd9\062" +
    "\uffd9\001\002\000\004\041\125\001\002\000\020\013\024" +
    "\015\023\016\025\017\022\020\017\025\021\031\020\001" +
    "\002\000\060\005\uffd0\006\uffd0\010\uffd0\014\uffd0\026\uffd0" +
    "\027\uffd0\030\uffd0\033\uffd0\034\uffd0\035\uffd0\036\uffd0\040" +
    "\uffd0\042\uffd0\043\uffd0\044\uffd0\045\uffd0\046\uffd0\047\uffd0" +
    "\050\uffd0\052\uffd0\053\uffd0\061\uffd0\062\uffd0\001\002\000" +
    "\060\005\uffbd\006\uffbd\010\uffbd\014\uffbd\026\uffbd\027\064" +
    "\030\uffbd\033\uffbd\034\uffbd\035\uffbd\036\uffbd\040\uffbd\042" +
    "\uffbd\043\uffbd\044\uffbd\045\uffbd\046\uffbd\047\uffbd\050\uffbd" +
    "\052\uffbd\053\uffbd\061\uffbd\062\uffbd\001\002\000\060\005" +
    "\uffbf\006\uffbf\010\uffbf\014\uffbf\026\uffbf\027\064\030\uffbf" +
    "\033\uffbf\034\uffbf\035\073\036\071\040\uffbf\042\uffbf\043" +
    "\uffbf\044\uffbf\045\uffbf\046\uffbf\047\uffbf\050\uffbf\052\uffbf" +
    "\053\uffbf\061\uffbf\062\uffbf\001\002\000\020\013\024\015" +
    "\023\016\025\017\022\020\017\025\021\031\020\001\002" +
    "\000\010\014\ufff2\042\ufff2\055\043\001\002\000\006\014" +
    "\ufff4\042\ufff4\001\002\000\006\002\ufffc\011\136\001\002" +
    "\000\004\002\000\001\002\000\006\012\141\056\137\001" +
    "\002\000\004\025\ufffb\001\002\000\004\025\142\001\002" +
    "\000\004\025\ufffa\001\002\000\006\026\145\056\143\001" +
    "\002\000\004\041\240\001\002\000\004\026\233\001\002" +
    "\000\004\041\146\001\002\000\020\013\024\015\023\016" +
    "\025\017\022\020\017\025\021\031\020\001\002\000\046" +
    "\004\156\007\151\013\051\022\155\023\162\024\152\031" +
    "\055\034\044\051\057\054\046\056\160\057\052\060\054" +
    "\064\154\065\047\067\045\070\060\072\053\001\002\000" +
    "\010\006\uffe6\014\uffe6\042\231\001\002\000\032\013\051" +
    "\031\055\034\044\051\057\054\046\056\056\057\052\060" +
    "\054\065\047\067\045\070\060\072\053\001\002\000\004" +
    "\056\010\001\002\000\004\014\217\001\002\000\032\013" +
    "\051\031\055\034\044\051\057\054\046\056\056\057\052" +
    "\060\054\065\047\067\045\070\060\072\053\001\002\000" +
    "\010\006\uffe5\014\uffe5\042\uffe5\001\002\000\032\013\051" +
    "\031\055\034\044\051\057\054\046\056\056\057\052\060" +
    "\054\065\047\067\045\070\060\072\053\001\002\000\042" +
    "\027\202\033\067\034\062\035\073\036\071\040\122\043" +
    "\072\044\065\045\075\046\070\047\066\050\074\052\063" +
    "\053\076\061\uffd8\062\uffd8\001\002\000\046\025\175\027" +
    "\uffcf\033\uffcf\034\uffcf\035\uffcf\036\uffcf\040\uffcf\043\uffcf" +
    "\044\uffcf\045\uffcf\046\uffcf\047\uffcf\050\uffcf\052\uffcf\053" +
    "\uffcf\055\176\061\uffcf\062\uffcf\001\002\000\006\061\173" +
    "\062\174\001\002\000\004\056\163\001\002\000\004\055" +
    "\164\001\002\000\032\013\051\031\055\034\044\051\057" +
    "\054\046\056\056\057\052\060\054\065\047\067\045\070" +
    "\060\072\053\001\002\000\036\027\064\033\067\034\062" +
    "\035\073\036\071\040\166\043\072\044\065\045\075\046" +
    "\070\047\066\050\074\052\063\053\076\001\002\000\032" +
    "\013\051\031\055\034\044\051\057\054\046\056\056\057" +
    "\052\060\054\065\047\067\045\070\060\072\053\001\002" +
    "\000\036\010\170\027\064\033\067\034\062\035\073\036" +
    "\071\043\072\044\065\045\075\046\070\047\066\050\074" +
    "\052\063\053\076\001\002\000\046\004\156\007\151\013" +
    "\051\022\155\023\162\024\152\031\055\034\044\051\057" +
    "\054\046\056\160\057\052\060\054\064\154\065\047\067" +
    "\045\070\060\072\053\001\002\000\004\014\172\001\002" +
    "\000\010\006\uffe1\014\uffe1\042\uffe1\001\002\000\010\006" +
    "\uffdc\014\uffdc\042\uffdc\001\002\000\010\006\uffdb\014\uffdb" +
    "\042\uffdb\001\002\000\034\013\051\026\120\031\055\034" +
    "\044\051\057\054\046\056\056\057\052\060\054\065\047" +
    "\067\045\070\060\072\053\001\002\000\032\013\051\031" +
    "\055\034\044\051\057\054\046\056\056\057\052\060\054" +
    "\065\047\067\045\070\060\072\053\001\002\000\042\006" +
    "\uffdf\014\uffdf\027\064\033\067\034\062\035\073\036\071" +
    "\042\uffdf\043\072\044\065\045\075\046\070\047\066\050" +
    "\074\052\063\053\076\001\002\000\004\026\201\001\002" +
    "\000\050\006\uffdd\014\uffdd\027\uffcc\033\uffcc\034\uffcc\035" +
    "\uffcc\036\uffcc\040\uffcc\042\uffdd\043\uffcc\044\uffcc\045\uffcc" +
    "\046\uffcc\047\uffcc\050\uffcc\052\uffcc\053\uffcc\061\uffcc\062" +
    "\uffcc\001\002\000\032\013\051\031\055\034\044\051\057" +
    "\054\046\056\056\057\052\060\054\065\047\067\045\070" +
    "\060\072\053\001\002\000\036\027\064\030\204\033\067" +
    "\034\062\035\073\036\071\043\072\044\065\045\075\046" +
    "\070\047\066\050\074\052\063\053\076\001\002\000\044" +
    "\027\uffce\033\uffce\034\uffce\035\uffce\036\uffce\040\uffce\043" +
    "\uffce\044\uffce\045\uffce\046\uffce\047\uffce\050\uffce\052\uffce" +
    "\053\uffce\055\205\061\uffce\062\uffce\001\002\000\032\013" +
    "\051\031\055\034\044\051\057\054\046\056\056\057\052" +
    "\060\054\065\047\067\045\070\060\072\053\001\002\000" +
    "\042\006\uffde\014\uffde\027\064\033\067\034\062\035\073" +
    "\036\071\042\uffde\043\072\044\065\045\075\046\070\047" +
    "\066\050\074\052\063\053\076\001\002\000\036\005\210" +
    "\027\064\033\067\034\062\035\073\036\071\043\072\044" +
    "\065\045\075\046\070\047\066\050\074\052\063\053\076" +
    "\001\002\000\046\004\156\007\151\013\051\022\155\023" +
    "\162\024\152\031\055\034\044\051\057\054\046\056\160" +
    "\057\052\060\054\064\154\065\047\067\045\070\060\072" +
    "\053\001\002\000\006\006\212\014\213\001\002\000\046" +
    "\004\156\007\151\013\051\022\155\023\162\024\152\031" +
    "\055\034\044\051\057\054\046\056\160\057\052\060\054" +
    "\064\154\065\047\067\045\070\060\072\053\001\002\000" +
    "\010\006\uffe2\014\uffe2\042\uffe2\001\002\000\004\014\215" +
    "\001\002\000\010\006\uffe3\014\uffe3\042\uffe3\001\002\000" +
    "\042\006\uffda\014\uffda\027\064\033\067\034\062\035\073" +
    "\036\071\042\uffda\043\072\044\065\045\075\046\070\047" +
    "\066\050\074\052\063\053\076\001\002\000\006\002\ufff8" +
    "\011\ufff8\001\002\000\004\042\221\001\002\000\046\004" +
    "\156\007\151\013\051\022\155\023\162\024\152\031\055" +
    "\034\044\051\057\054\046\056\223\057\052\060\054\064" +
    "\154\065\047\067\045\070\060\072\053\001\002\000\004" +
    "\014\224\001\002\000\050\025\175\027\uffcf\033\uffcf\034" +
    "\uffcf\035\uffcf\036\uffcf\040\uffcf\041\015\043\uffcf\044\uffcf" +
    "\045\uffcf\046\uffcf\047\uffcf\050\uffcf\052\uffcf\053\uffcf\055" +
    "\176\061\uffcf\062\uffcf\001\002\000\010\006\uffe0\014\uffe0" +
    "\042\uffe0\001\002\000\036\010\226\027\064\033\067\034" +
    "\062\035\073\036\071\043\072\044\065\045\075\046\070" +
    "\047\066\050\074\052\063\053\076\001\002\000\046\004" +
    "\156\007\151\013\051\022\155\023\162\024\152\031\055" +
    "\034\044\051\057\054\046\056\160\057\052\060\054\064" +
    "\154\065\047\067\045\070\060\072\053\001\002\000\004" +
    "\014\230\001\002\000\010\006\uffe4\014\uffe4\042\uffe4\001" +
    "\002\000\046\004\156\007\151\013\051\022\155\023\162" +
    "\024\152\031\055\034\044\051\057\054\046\056\160\057" +
    "\052\060\054\064\154\065\047\067\045\070\060\072\053" +
    "\001\002\000\006\006\uffe7\014\uffe7\001\002\000\004\041" +
    "\234\001\002\000\020\013\024\015\023\016\025\017\022" +
    "\020\017\025\021\031\020\001\002\000\046\004\156\007" +
    "\151\013\051\022\155\023\162\024\152\031\055\034\044" +
    "\051\057\054\046\056\160\057\052\060\054\064\154\065" +
    "\047\067\045\070\060\072\053\001\002\000\004\014\237" +
    "\001\002\000\006\002\ufff9\011\ufff9\001\002\000\020\013" +
    "\024\015\023\016\025\017\022\020\017\025\021\031\020" +
    "\001\002\000\006\026\ufff6\040\242\001\002\000\004\056" +
    "\143\001\002\000\004\026\ufff7\001\002\000\004\002\ufffd" +
    "\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\242\000\006\002\005\003\003\001\001\000\006\004" +
    "\134\006\133\001\001\000\004\005\010\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\011\015\001\001\000\004\020\041\001\001\000" +
    "\002\001\001\000\004\011\037\001\001\000\006\011\025" +
    "\012\026\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\011\031\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\011\034\001\001" +
    "\000\002\001\001\000\006\011\025\012\036\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\015\047\001\001\000\004\015\127\001" +
    "\001\000\002\001\001\000\004\015\126\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\015\060\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\015\113\001\001\000\004" +
    "\015\112\001\001\000\004\015\110\001\001\000\004\015" +
    "\107\001\001\000\004\015\106\001\001\000\004\015\105" +
    "\001\001\000\004\015\104\001\001\000\004\015\103\001" +
    "\001\000\004\015\102\001\001\000\004\015\101\001\001" +
    "\000\004\015\100\001\001\000\004\015\077\001\001\000" +
    "\004\015\076\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\015\115" +
    "\016\116\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\015\115\016\122" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\011" +
    "\125\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\011\131\001\001\000\004\020\132\001" +
    "\001\000\002\001\001\000\006\004\243\006\133\001\001" +
    "\000\002\001\001\000\004\007\137\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\010\143" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\011\146\001\001\000\012\013\152\014\147" +
    "\015\156\016\160\001\001\000\002\001\001\000\004\015" +
    "\224\001\001\000\004\005\217\001\001\000\002\001\001" +
    "\000\004\015\215\001\001\000\002\001\001\000\004\015" +
    "\206\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\015" +
    "\164\001\001\000\002\001\001\000\004\015\166\001\001" +
    "\000\002\001\001\000\012\013\170\014\147\015\156\016" +
    "\160\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\015\115\016\177\001" +
    "\001\000\004\015\176\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\015\202\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\015\205\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\013\210\014" +
    "\147\015\156\016\160\001\001\000\002\001\001\000\012" +
    "\013\213\014\147\015\156\016\160\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\013\221\014" +
    "\147\015\156\016\160\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\012\013" +
    "\226\014\147\015\156\016\160\001\001\000\002\001\001" +
    "\000\002\001\001\000\012\013\231\014\147\015\156\016" +
    "\160\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\011\234\001\001\000\012\013\235\014\147\015\156\016" +
    "\160\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\011\240\001\001\000\002\001\001\000\004\010\242\001" +
    "\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
 return lexer.next_token(); 
    }


	PalleneLexer lexer;
	Document document;
	Element root, tempE;


	public parser(PalleneLexer  lexer, Document document, Element root, Element tempE){
	    this.lexer = lexer;
	    this.document = document;
	    this.root = root;
	    this.tempE = tempE;
    }


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$parser$actions {
  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$parser$do_action_part00000000(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= Programma EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Program start_val = (Program)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // Programma ::= Global Functions 
            {
              Program RESULT =null;
		int globalleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int globalright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Global global = (Global)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int functionsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int functionsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		LinkedList<Function> functions = (LinkedList<Function>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                Program program = new Program("ProgramOp", global, functions);

                Node g = new Global("Global");
                Node f = new Function("Functions");

                program.element = document.createElement("ProgramOp");
                root = document.createElement("Global");

                for(VarDecl decl: global.getVarDecls()){
                    g.addChild(decl);
                    root.appendChild(decl.element);
                }

                program.element.appendChild(root);
                root = document.createElement("Function");

                program.addChild(g);
                //program.addChild(new Expr("/Global"));

                for (Function fu: functions){
                    for (Def_fun def: fu.getDef()){
                        f.addChild(def);
                        root.appendChild(def.element);
                    }
                }

                program.element.appendChild(root);
                program.addChild(f);
                RESULT = program;

                //System.out.println(f.listChildren());
                //System.out.println(program.nodeTemp.listChildren());
                //System.out.println(program.nodeTemp.listChildren());
           
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Programma",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // Global ::= GLOBAL Var_decls END 
            {
              Global RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LinkedList<VarDecl> var = (LinkedList<VarDecl>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		

            RESULT = new Global("Global",var);
            RESULT.element = document.createElement("GLOBAL");

            for (VarDecl n: var){
                RESULT.addChild(n);
                RESULT.element.appendChild(n.element);
                }
            //ok


        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Global",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // Global ::= 
            {
              Global RESULT =null;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Global",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // Functions ::= Def_fun Functions 
            {
              LinkedList<Function> RESULT =null;
		int def_funleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int def_funright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Def_fun def_fun = (Def_fun)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int functionsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int functionsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		LinkedList<Function> functions = (LinkedList<Function>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            //System.out.println(def_fun.listChildren());
                RESULT = new LinkedList<Function>();
                Function f = new Function("FunctionOp");
                f.addDefFun(def_fun);

                f.element = document.createElement("FunctionOp");
                f.element.appendChild(def_fun.element);

                RESULT.add(f);

                for (Function fs: functions) {
                    RESULT.add(fs);
                }

            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Functions",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // Functions ::= Def_fun 
            {
              LinkedList<Function> RESULT =null;
		int def_funleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int def_funright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Def_fun def_fun = (Def_fun)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

                RESULT = new LinkedList<Function>();
                Function f = new Function("FunctionOp");
                f.addDefFun(def_fun);
                //f.addDefFun(new Def_fun("/DefFunOp"));

                f.element = document.createElement("FunctionOp");
                f.element.appendChild(def_fun.element);

                RESULT.add(f);
                //System.out.println(def_fun.listChildren());
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Functions",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // Function_name ::= ID 
            {
              Expr RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                 RESULT = new ID("ID",id);
                //SintaxTree
                 RESULT.element = document.createElement("ID");
                 Attr attr = document.createAttribute("value");
                 attr.setValue(id);
                 RESULT.element.setAttributeNode(attr);

                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Function_name",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // Function_name ::= MAIN 
            {
              Expr RESULT =null;
		int mainleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mainright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String main = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    RESULT = new ID("ID","main");

                    //SintaxTree
                    RESULT.element = document.createElement("ID");
                    Attr attr = document.createAttribute("value");
                    attr.setValue("main");
                    RESULT.element.setAttributeNode(attr);
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Function_name",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // Def_fun ::= FUNCTION Function_name LPAR Par_decls RPAR COLON Type Statements END 
            {
              Def_fun RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Expr name = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int par_declsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int par_declsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		LinkedList<ParDecl> par_decls = (LinkedList<ParDecl>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LinkedList<Statement> statements = (LinkedList<Statement>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		

        RESULT = new Def_fun("DefFunOp", new ID("Id",name.getName()), par_decls, type, statements);
        RESULT.addChild(new ID("Id", name.getName()));
        //ParDecl e = new ParDecl("ParDeclOp",new ID("Id",id),type);

        //Sintax Tree
        //tempE = document.createElement("ParDeclOp");

        RESULT.element = document.createElement("DefFunOp");
        root = document.createElement("ID");
        Attr attr = document.createAttribute("value");
        attr.setValue(name.getName());
        root.setAttributeNode(attr);
        RESULT.element.appendChild(root);

        for(ParDecl par: par_decls) {
           RESULT.addChild(par);
           //System.out.println(par.listChildren());
           RESULT.element.appendChild(par.element);
        }

        //RESULT.element.appendChild(tempE);
        RESULT.element.appendChild(type.element);

        //RESULT.addChild(e);
        RESULT.addChild(type);
        //RESULT.addChild(new Node("/ParDeclop"));
        Statement e2 = new Statement("Statement");
        tempE = document.createElement("Statement");


        for (Statement stat: statements) {
            e2.addChild(stat);
            tempE.appendChild(stat.element);
            //ok
            //System.out.println(stat.element);
        }

        RESULT.element.appendChild(tempE);
        RESULT.addChild(e2);


        //RESULT.addChild(new Expr("/Statement"));

        //ok



        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Def_fun",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // Def_fun ::= FUNCTION Function_name LPAR RPAR COLON Type Statements END 
            {
              Def_fun RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Expr name = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LinkedList<Statement> statements = (LinkedList<Statement>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		

            RESULT = new Def_fun("DefFunOp", new ID("Id",name.getName()), type, statements);
            RESULT.addChild(new ID("Id", name.getName()));
            RESULT.addChild(type);

            for(Node n: statements){
                RESULT.addChild(n);
            }

            //Sintax Tree
            RESULT.element = document.createElement("DefFunOp");
            root = document.createElement("ID");
            Attr attr = document.createAttribute("value");
            attr.setValue(name.getName());
            root.setAttributeNode(attr);
            RESULT.element.appendChild(root);
            RESULT.element.appendChild(type.element);
            for(Node n: statements){
                RESULT.element.appendChild(n.element);
            }

            //System.out.println(RESULT.nodeTemp.listChildren());


        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Def_fun",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // Par_decls ::= ID COLON Type COMMA Par_decls 
            {
              LinkedList<ParDecl> RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int par_declsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int par_declsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		LinkedList<ParDecl> par_decls = (LinkedList<ParDecl>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new LinkedList<ParDecl>();
            ParDecl p = new ParDecl("ParDeclOp", new ID("ID",id), type);
            p.addChild(new ID("ID",id));
            p.addChild(type);

             //Sintax Tree
             p.element = document.createElement("ParDeclOp");
             root = document.createElement("ID");
             Attr attr = document.createAttribute("value");
             attr.setValue(id);
             root.setAttributeNode(attr);
             p.element.appendChild(root);
             p.element.appendChild(type.element);

             RESULT.add(p);

             for (ParDecl parD: par_decls) {
                RESULT.add(parD);
             }

             //ok

            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Par_decls",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // Par_decls ::= ID COLON Type 
            {
              LinkedList<ParDecl> RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

            RESULT = new LinkedList<ParDecl>();
            ParDecl p = new ParDecl("ParDeclOp", new ID("ID",id), type);
            p.addChild(new ID("ID",id));
            p.addChild(type);

            //Sintax Tree
            p.element = document.createElement("ParDeclOp");
            root = document.createElement("ID");
            Attr attr = document.createAttribute("value");
            attr.setValue(id);
            root.setAttributeNode(attr);
            p.element.appendChild(root);
            p.element.appendChild(type.element);

            RESULT.add(p);
            //ok
            //RESULT.add(new ParDecl("/ParDeclOp", new ID(id,id), type));
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Par_decls",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // Var_decls ::= Var_decls SEMICOLON ID COLON Type Var_init_value 
            {
              LinkedList<VarDecl> RESULT =null;
		int var_declsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int var_declsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		LinkedList<VarDecl> var_decls = (LinkedList<VarDecl>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int var_initleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int var_initright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		VarIntValue var_init = (VarIntValue)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                ID i = new ID("Id",id);
                RESULT = new LinkedList<VarDecl>();

                for (VarDecl v: var_decls) {
                    RESULT.add(v);
                }

                VarDecl varD = new VarDecl("VarDeclOp",i ,type);

                varD.addChild(i);
                varD.addChild(type);
                if (var_init != null) {
                varD.addChild(var_init);
                }
                //varD.addChild(new Expr("/ASSIGMENT"));

                //Sintax Tree
                varD.element = document.createElement("VarDeclOp");
                root = document.createElement("ID");
                Attr attr = document.createAttribute("value");
                attr.setValue(id);
                root.setAttributeNode(attr);

                varD.element.appendChild(root);
                varD.element.appendChild(type.element);
                if (var_init != null) {
                varD.element.appendChild(var_init.element);
                }

                RESULT.add(varD);



                //RESULT.add(new VarDecl("/VarDeclOp",new ID(id,id),type,var_init));

            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Var_decls",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // Var_decls ::= ID COLON Type Var_init_value 
            {
              LinkedList<VarDecl> RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int var_initleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int var_initright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		VarIntValue var_init = (VarIntValue)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

                ID i = new ID("Id",id);
                RESULT = new LinkedList<VarDecl>();


                VarDecl varD = new VarDecl("VarDeclOp",i,type);
                varD.addChild(i);
                varD.addChild(type);
                if (var_init != null) {
                varD.addChild(var_init);
                }

                //Sintax Tree
                varD.element = document.createElement("VarDeclOp");
                root = document.createElement("ID");
                Attr attr = document.createAttribute("value");
                attr.setValue(id);
                root.setAttributeNode(attr);

                varD.element.appendChild(root);
                varD.element.appendChild(type.element);
                if (var_init != null) {
                varD.element.appendChild(var_init.element);
                }

                RESULT.add(varD);

               //RESULT.add(new VarDecl("/VarDeclOp",new ID(id,id),type,var_init));
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Var_decls",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // Var_init_value ::= ASSIGN Expr 
            {
              VarIntValue RESULT =null;
		int assignleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int assignright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String assign = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

                //System.out.println(expr.listChildren());

                RESULT = new VarIntValue("Var_init",expr);
                RESULT.addChild(expr);

                //Sintax Tree
                RESULT.element = document.createElement("Var_init");
                RESULT.element.appendChild(expr.element);
                //System.out.println(RESULT.listChildren());


            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Var_init_value",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // Var_init_value ::= 
            {
              VarIntValue RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("Var_init_value",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // Type ::= NIL 
            {
              Type RESULT =null;
		
            RESULT = new Type("NIL");
            //Sintax Tree
            RESULT.element = document.createElement("NIL");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // Type ::= INT 
            {
              Type RESULT =null;
		int int_tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int int_tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String int_t = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new Type("INT");
            //Sintax Tree
            RESULT.element = document.createElement("INT");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // Type ::= BOOL 
            {
              Type RESULT =null;
		
            RESULT = new Type("BOOL");
            RESULT.element = document.createElement("BOOL");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // Type ::= FLOAT 
            {
              Type RESULT =null;
		
            RESULT = new Type("FLOAT");
            RESULT.element = document.createElement("FLOAT");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // Type ::= STRING 
            {
              Type RESULT =null;
		
            RESULT = new Type("STRING");
            //Sintax Tree
            RESULT.element = document.createElement("STRING");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // Type ::= BLPAR Type BRPAR 
            {
              Type RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            RESULT = type;
            RESULT.element = type.element;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // Type ::= LPAR Types RPAR ARROW Type 
            {
              Type RESULT =null;
		int typesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int typesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		LinkedList<Type> types = (LinkedList<Type>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new Type("Complex_Type");
            for (Type tp: types) {
                RESULT.addChild(tp);
                RESULT.element = tp.element;
            }

            RESULT.addChild(type);
            RESULT.element = type.element;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // Type ::= LPAR RPAR ARROW Type 
            {
              Type RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = type;
            RESULT.element = type.element;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // Types ::= Type COMMA Types 
            {
              LinkedList<Type> RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int typesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int typesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		LinkedList<Type> types = (LinkedList<Type>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            LinkedList<Type> tp = new LinkedList<Type>();
            tp.add(type);
            //tp.element = type.element;

            for(Type t: types) {
                tp.add(t);
                //tp.element = t.element;
            }

            RESULT = tp;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Types",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // Types ::= Type 
            {
              LinkedList<Type> RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            LinkedList<Type> t = new LinkedList<Type>();
            t.add(type);

            RESULT = t;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Types",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // Statements ::= Stat SEMICOLON Statements 
            {
              LinkedList<Statement> RESULT =null;
		int statleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int statright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Statement stat = (Statement)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		LinkedList<Statement> statements = (LinkedList<Statement>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

        RESULT = new LinkedList<Statement>();
        RESULT.add(stat);

        for (Statement s: statements) {
              RESULT.add(s);
        }

        //ok
        //RESULT.add(new Statement("/STATEMENT"));
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Statements",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // Statements ::= Stat 
            {
              LinkedList<Statement> RESULT =null;
		int statleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int statright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Statement stat = (Statement)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

            RESULT = new LinkedList<Statement>();
            RESULT.add(stat);
            //RESULT.add(new Statement("/"+stat.getName()));

            //ok
            //System.out.println(stat.listChildren());
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Statements",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // Stat ::= NOP 
            {
              Statement RESULT =null;
		
            RESULT = new NOP("NoOperation");
            RESULT.element = document.createElement("NoOperation");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Stat",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // Stat ::= WHILE Expr DO Statements END 
            {
              Statement RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LinkedList<Statement> statements = (LinkedList<Statement>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            RESULT = new WHILE_DO("WHILE_STATEMENTS");
            RESULT.addChild(expr);
            RESULT.element = document.createElement("WHILE_STATEMENTS");
            RESULT.element.appendChild(expr.element);


            for (Statement stat: statements) {
                RESULT.addChild(stat);
                RESULT.element.appendChild(stat.element);
            }
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Stat",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // Stat ::= IF Expr THEN Statements ELSE Statements END 
            {
              Statement RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		LinkedList<Statement> statements = (LinkedList<Statement>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int statements2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int statements2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LinkedList<Statement> statements2 = (LinkedList<Statement>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            RESULT = new IF_THEN_ELSE("IF_THEN_ELSE_STATEMENT");
            RESULT.addChild(expr);

            RESULT.element = document.createElement("IF_THEN_ELSE_STATEMENT");
            RESULT.element.appendChild(expr.element);

            for (Statement s: statements) {
                RESULT.addChild(s);
                RESULT.element.appendChild(s.element);
            }

            Statement elseS = new Statement("ELSE");
            elseS.element = document.createElement("ELSE");

            for (Statement s2: statements2) {
                elseS.addChild(s2);
                elseS.element.appendChild(s2.element);
            }

            RESULT.addChild(elseS);
            RESULT.element.appendChild(elseS.element);

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Stat",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // Stat ::= IF Expr THEN Statements END 
            {
              Statement RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LinkedList<Statement> statements = (LinkedList<Statement>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            RESULT = new IF_THEN("IF_THEN_STATEMENT");
            RESULT.addChild(expr);

            RESULT.element = document.createElement("IF_THEN_STATEMENT");
            RESULT.element.appendChild(expr.element);

            for (Statement s: statements) {
                RESULT.addChild(s);
                RESULT.element.appendChild(s.element);
            }

            //ok
            //System.out.println(RESULT.listChildren());
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Stat",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // Stat ::= FOR ID ASSIGN Expr COMMA Expr DO Statements END 
            {
              Statement RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LinkedList<Statement> statements = (LinkedList<Statement>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            RESULT = new FOR("FOR_STATEMENT");

            FOR_ASSIGN forAss = new FOR_ASSIGN("FOR_ASSIGNMENT",new ID("ID",id), expr);
            forAss.element = document.createElement("FOR_ASSIGNMENT");

            forAss.addChild(new ID("ID",id));
            forAss.addChild(expr);

            root = document.createElement("ID");
            Attr attr = document.createAttribute("value");
            attr.setValue(id);
            root.setAttributeNode(attr);
            forAss.element.appendChild(root);

            forAss.element.appendChild(expr.element);

            RESULT.element = document.createElement("FOR_STATEMENT");


            RESULT.addChild(forAss);
            RESULT.element.appendChild(forAss.element);

            RESULT.addChild(expr2);
            RESULT.element.appendChild(expr2.element);

            for (Statement s: statements) {
                RESULT.addChild(s);
                RESULT.element.appendChild(s.element);
            }

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Stat",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // Stat ::= LOCAL Var_decls SEMICOLON Statements END 
            {
              Statement RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		LinkedList<VarDecl> var = (LinkedList<VarDecl>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LinkedList<Statement> statements = (LinkedList<Statement>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            RESULT = new LOCAL("LOCAL_STATEMENT");
            RESULT.element = document.createElement("LOCAL_STATEMENT");

            for( VarDecl v: var){
                RESULT.addChild(v);
                RESULT.element.appendChild(v.element);
            }

            for( Statement s: statements){
                RESULT.addChild(s);
                RESULT.element.appendChild(s.element);
            }
            //problema su SEMICOLON -> RISOLTO CAMBIANDO LA PRODUZIONE VAR_DECLOP
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Stat",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // Stat ::= ID ASSIGN Expr 
            {
              Statement RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new ASSIGNMENT("AssignmentOp", new ID(id,id), expr);

            RESULT.addChild(new ID(id,id));
            RESULT.addChild(expr);

            //Sintax Tree
            RESULT.element = document.createElement("AssignmentOp");
            root = document.createElement("ID");
            Attr attr = document.createAttribute("value");
            attr.setValue(id);
            root.setAttributeNode(attr);
            RESULT.element.appendChild(root);
            RESULT.element.appendChild(expr.element);

            //System.out.println(RESULT.element.getTagName());
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Stat",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // Stat ::= Expr SLPAR Expr SRPAR ASSIGN Expr 
            {
              Statement RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int expr3left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expr3right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr3 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new ASSIGNMENT("AssignmentOp");
            //Sintax Tree
            RESULT.element = document.createElement("AssignmentOp");


            ARRAY_STAT arrayStat = new ARRAY_STAT("ArrayStat");
            arrayStat.element = document.createElement("ArrayStat");

            arrayStat.addChild(expr);
            arrayStat.element.appendChild(expr.element);

            arrayStat.addChild(expr2);
            arrayStat.element.appendChild(expr2.element);

            RESULT.addChild(arrayStat);
            RESULT.element.appendChild(arrayStat.element);

            RESULT.addChild(expr3);
            RESULT.element.appendChild(expr3.element);


        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Stat",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // Stat ::= ID LPAR Exprs RPAR 
            {
              Statement RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exprsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exprsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LinkedList<Expr> exprs = (LinkedList<Expr>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Stat",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // Stat ::= Exprs READ 
            {
              Statement RESULT =null;
		int exprsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exprsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LinkedList<Expr> exprs = (LinkedList<Expr>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            RESULT = new READ("READ_STATEMENT");
            RESULT.element = document.createElement("READ_STATEMENT");

            for (Expr e: exprs) {
                RESULT.addChild(e);
                RESULT.element.appendChild(e.element);
            }
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Stat",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // Stat ::= Exprs WRITE 
            {
              Statement RESULT =null;
		int exprsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exprsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LinkedList<Expr> exprs = (LinkedList<Expr>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            RESULT = new WRITE("WRITE_STATEMENT");
            RESULT.element = document.createElement("WRITE_STATEMENT");

            for (Expr e: exprs) {
                RESULT.addChild(e);
                RESULT.element.appendChild(e.element);
            }
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Stat",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // Stat ::= RETURN Expr 
            {
              Statement RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            //RESULT = new LinkedList<Statement>();
            RESULT = new RETURN("RETURN");
            RESULT.addChild(expr);
            //RESULT.add(new RETURN("/RETURN"));

            //Sintax Tree
            RESULT.element = document.createElement("RETURN_STATEMENT");
            RESULT.element.appendChild(expr.element);

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Stat",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // Exprs ::= Expr COMMA Exprs 
            {
              LinkedList<Expr> RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int exprsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exprsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		LinkedList<Expr> exprs = (LinkedList<Expr>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

            RESULT = new LinkedList<Expr>();

            RESULT.add(expr);

            for (Expr ex: exprs)
                RESULT.add(ex);

            //ok
            /*RESULT = new LinkedList<Expr>();
            RESULT.add( new SHARP_EXPR(expr.getName()) );
            RESULT.add( new STRING_CONST(expr.getName(),expr.getStringValue()) );*/
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Exprs",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // Exprs ::= Expr 
            {
              LinkedList<Expr> RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

            RESULT = new LinkedList<Expr>();
            RESULT.add(expr);

            //System.out.println(expr.listChildren());
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Exprs",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // Expr ::= NIL 
            {
              Expr RESULT =null;
		
            RESULT = new NIL_CONST("NIL_CONST");
            RESULT.element = document.createElement("NIL_CONST");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // Expr ::= TRUE 
            {
              Expr RESULT =null;
		
            RESULT = new BOOLEAN_CONST("TRUE_CONST", true);
            RESULT.element = document.createElement("TRUE");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // Expr ::= FALSE 
            {
              Expr RESULT =null;
		
            RESULT = new BOOLEAN_CONST("FALSE_CONST", false);
            RESULT.element = document.createElement("FALSE");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // Expr ::= FLOAT_CONST 
            {
              Expr RESULT =null;
		int float_valueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int float_valueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String float_value = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new FLOAT_CONST("FLOAT_CONST", float_value);

            //Sintax Tree
            RESULT.element = document.createElement("FLOAT_CONST");
            Attr attr = document.createAttribute("value");
            attr.setValue(float_value);
            RESULT.element.setAttributeNode(attr);
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // Expr ::= EXP 
            {
              Expr RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new FLOAT_CONST("FLOAT_CONST", e);

            //Sintax Tree
             RESULT.element = document.createElement("FLOAT_CONST");
             Attr attr = document.createAttribute("value");
             attr.setValue(e);
             RESULT.element.setAttributeNode(attr);
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // Expr ::= INT_CONST 
            {
              Expr RESULT =null;
		int int_valueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int int_valueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String int_value = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
           RESULT = new INT_CONST("INT_CONST", int_value);

           //Sintax Tree
          RESULT.element = document.createElement("INT_CONST");
          Attr attr = document.createAttribute("value");
          attr.setValue(int_value);
          RESULT.element.setAttributeNode(attr);

          //System.out.println(RESULT.listChildren());
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // Expr ::= STRING_CONST 
            {
              Expr RESULT =null;
		int stringleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int stringright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String string = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

            RESULT = new STRING_CONST("STRING_CONST",string);

            //Sintax Tree
            RESULT.element = document.createElement("STRING_CONST");
            Attr attr = document.createAttribute("value");
            attr.setValue(string);
            RESULT.element.setAttributeNode(attr);
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // Expr ::= BLPAR BRPAR COLON Type 
            {
              Expr RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new TYPE_CONST(type.getName());
            RESULT.element = type.element;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // Expr ::= ID 
            {
              Expr RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new ID("ID",id);
            //SintaxTree
            RESULT.element = document.createElement("ID");
            Attr attr = document.createAttribute("value");
            attr.setValue(id);
            RESULT.element.setAttributeNode(attr);

            //ok

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // Expr ::= Expr SLPAR Expr SRPAR 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            RESULT = new Expr("[]_EXPR");
            RESULT.addChild(expr);
            RESULT.addChild(expr2);

            //sintax tree
            RESULT.element = document.createElement("[]_EXPR");
            RESULT.element.appendChild(expr.element);
            RESULT.element.appendChild(expr2.element);

         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // Expr ::= ID LPAR RPAR 
            {
              Expr RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
            RESULT = new FUNCT_EXPR("FUNCT_EXPRESSION", new ID(id,id));
            RESULT.addChild(new ID(id,id));

            PARAMETERS_F paramters = new PARAMETERS_F("PARAMETERS");
            RESULT.addChild(paramters);

            RESULT.element = document.createElement("FUNCT_EXPRESSION");
            paramters.element = document.createElement("PARAMETERS");

            root = document.createElement("ID");
            Attr attr = document.createAttribute("value");
            attr.setValue(id);
            root.setAttributeNode(attr);
            RESULT.element.appendChild(root);

            RESULT.element.appendChild(paramters.element);

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // Expr ::= ID LPAR Exprs RPAR 
            {
              Expr RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exprsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exprsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LinkedList<Expr> exprs = (LinkedList<Expr>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
           RESULT = new FUNCT_EXPR("FUNCT_EXPRESSION", new ID(id,id),exprs);
           RESULT.addChild(new ID(id,id));

           PARAMETERS_F paramters = new PARAMETERS_F("PARAMETERS");

           for ( Expr e: exprs)
                paramters.addChild(e);

           RESULT.addChild(paramters);

            //Sintax Tree
           RESULT.element = document.createElement("FUNCT_EXPRESSION");
           paramters.element = document.createElement("PARAMETERS");

           root = document.createElement("ID");
           Attr attr = document.createAttribute("value");
           attr.setValue(id);
           root.setAttributeNode(attr);
           RESULT.element.appendChild(root);

           for ( Expr e: exprs)
               paramters.element.appendChild(e.element);

           RESULT.element.appendChild(paramters.element);



            //ok
           //System.out.println(RESULT.getName());

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // Expr ::= Expr PLUS Expr 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new PLUS("AddOp");

            RESULT.addChild(expr);
            RESULT.addChild(expr2);

            //Sintax Tree
            root = document.createElement("AddOp");
            root.appendChild(expr.element);
            root.appendChild(expr2.element);

            //ok
            //System.out.println(RESULT.getName());

            RESULT.element = root;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // Expr ::= Expr MINUS Expr 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new MINUS("Minus");

            RESULT.addChild(expr);
            RESULT.addChild(expr2);

            //Sintax Tree
            root = document.createElement("Minus");
            root.appendChild(expr.element);
            root.appendChild(expr2.element);

            RESULT.element = root;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // Expr ::= Expr TIMES Expr 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new TIMES("Times");

            RESULT.addChild(expr);
            RESULT.addChild(expr2);

            //Sintax Tree
            root = document.createElement("Times");
            root.appendChild(expr.element);
            root.appendChild(expr2.element);

            RESULT.element = root;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // Expr ::= Expr DIV Expr 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new DIV("Div");

            RESULT.addChild(expr);
            RESULT.addChild(expr2);

            //Sintax Tree
            root = document.createElement("Div");
            root.appendChild(expr.element);
            root.appendChild(expr2.element);

            RESULT.element = root;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // Expr ::= Expr AND Expr 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new AND_R("And");

            RESULT.addChild(expr);
            RESULT.addChild(expr2);

            //Sintax Tree
            root = document.createElement("And");
            root.appendChild(expr.element);
            root.appendChild(expr2.element);

            RESULT.element = root;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // Expr ::= Expr OR Expr 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new OR_R("Or");

            RESULT.addChild(expr);
            RESULT.addChild(expr2);

            //Sintax Tree
            root = document.createElement("Or");
            root.appendChild(expr.element);
            root.appendChild(expr2.element);

            RESULT.element = root;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // Expr ::= Expr GT Expr 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new GT_R("Greater_Than");

            RESULT.addChild(expr);
            RESULT.addChild(expr2);

            //Sintax Tree
            root = document.createElement("Greater_Than");
            root.appendChild(expr.element);
            root.appendChild(expr2.element);

            RESULT.element = root;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // Expr ::= Expr GE Expr 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new GE_R("Greater_Equal");

            RESULT.addChild(expr);
            RESULT.addChild(expr2);

            //Sintax Tree
            root = document.createElement("Greater_Equal");
            root.appendChild(expr.element);
            root.appendChild(expr2.element);

            RESULT.element = root;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // Expr ::= Expr LT Expr 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new LT_R("Less_Than");

            RESULT.addChild(expr);
            RESULT.addChild(expr2);

            //Sintax Tree
            root = document.createElement("Less_Than");
            root.appendChild(expr.element);
            root.appendChild(expr2.element);

            RESULT.element = root;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // Expr ::= Expr LE Expr 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new LE_R("Less_Equal");

            RESULT.addChild(expr);
            RESULT.addChild(expr2);

            //Sintax Tree
            root = document.createElement("Less_Equal");
            root.appendChild(expr.element);
            root.appendChild(expr2.element);

            RESULT.element = root;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // Expr ::= Expr EQ Expr 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new EQ_R("Equal");

            RESULT.addChild(expr);
            RESULT.addChild(expr2);

            //Sintax Tree
            root = document.createElement("Equal");
            root.appendChild(expr.element);
            root.appendChild(expr2.element);

            RESULT.element = root;
            //ok
            //System.out.println(RESULT.getName());
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // Expr ::= Expr NE Expr 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expr2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expr2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr2 = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new NE_R("Not_Equal");

            RESULT.addChild(expr);
            RESULT.addChild(expr2);

            //Sintax Tree
            root = document.createElement("Not_Equal");
            root.appendChild(expr.element);
            root.appendChild(expr2.element);

            RESULT.element = root;
            //System.out.println(RESULT.listChildren());
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // Expr ::= MINUS Expr 
            {
              Expr RESULT =null;
		int minusleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int minusright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String minus = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new MINUS_EXPR("UMINUS", expr);
            RESULT.element = document.createElement("UMINUS");

            RESULT.addChild(expr);
            RESULT.element.appendChild(expr.element);
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // Expr ::= NOT Expr 
            {
              Expr RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = new NOT_EXPR("NOT_EXPRESSION", expr);
            RESULT.element = document.createElement("NOT_EXPRESSION");
            RESULT.addChild(expr);
            RESULT.element.appendChild(expr.element);

            //System.out.println(RESULT.listChildren());
            //ok
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // Expr ::= SHARP Expr 
            {
              Expr RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expr expr = (Expr)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

            RESULT = new SHARP_EXPR("SHARP_EXPR");
            RESULT.addChild(expr);

            //SintaxTree Element
            RESULT.element = document.createElement("SHARP_EXPR");
            root = document.createElement("SHARP");
            Attr attr = document.createAttribute("value");
            attr.setValue("#");
            root.setAttributeNode(attr);
            RESULT.element.appendChild(root);

            RESULT.element.appendChild(expr.element);

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
              return CUP$parser$do_action_part00000000(
                               CUP$parser$act_num,
                               CUP$parser$parser,
                               CUP$parser$stack,
                               CUP$parser$top);
    }
}

}
